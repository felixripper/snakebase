<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <!-- viewport-fit=cover eklendi -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <title>Eat & Grow</title>
    <script src="https://cdn.jsdelivr.net/npm/@farcade/game-sdk@0.2.1/dist/index.min.js"></script>
    <style>
      :root {
        --ui-safe: env(safe-area-inset-bottom, 0px);
      }
      html,
      body {
        margin: 0;
        padding: 0;
        /* Daha stabil görünüm için vh fallback + overscroll kapalı */
        height: 100vh;
        width: 100vw;
        background: #0b0f1a;
        overflow: hidden;
        touch-action: none;
        -webkit-tap-highlight-color: transparent;
        overscroll-behavior: none;
        font-family:
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Helvetica,
          Arial,
          sans-serif;
        color: #fff;
      }
      /* Destek varsa sabit viewport birimlerine geç */
      @supports (height: 100svh) {
        html,
        body {
          height: 100svh;
        }
      }

      .hud {
        position: fixed;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 12px;
        padding: 8px 12px;
        background: rgba(0, 0, 0, 0.35);
        backdrop-filter: blur(6px);
        border-radius: 12px;
        font-weight: 700;
        letter-spacing: 0.4px;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.35);
        user-select: none;
        pointer-events: none;
        z-index: 5;
      }
      #wrap {
        position: fixed;
        inset: 0;
        display: grid;
        place-items: center;
      }
      /* Canvas: 2:3 oranını korurken stabil viewport birimlerini kullan */
      #canvas {
        /* Fallback (vh) */
        width: min(100vw, 66.666vh);
        height: calc(min(100vw, 66.666vh) * 1.5);
        image-rendering: pixelated;
        image-rendering: crisp-edges;
        border-radius: 16px;
        box-shadow:
          0 10px 40px rgba(0, 0, 0, 0.5),
          inset 0 0 0 2px rgba(255, 255, 255, 0.06);
        background: radial-gradient(120% 120% at 50% 0%, #0b1228 0%, #070b18 60%, #05070f 100%);
        max-height: 100vh;
        max-width: 100vw;
      }
      /* Destek varsa svh ile override */
      @supports (height: 100svh) {
        #canvas {
          width: min(100vw, 66.666svh);
          height: calc(min(100vw, 66.666svh) * 1.5);
          max-height: 100svh;
          max-width: 100vw;
        }
      }

      .overlay {
        position: fixed;
        inset: 0;
        display: grid;
        place-items: center;
        background: linear-gradient(to bottom right, rgba(5, 8, 20, 0.75), rgba(5, 8, 16, 0.85));
        backdrop-filter: blur(4px);
      }
      .panel {
        width: min(92vw, 460px);
        padding: 20px 18px 16px;
        background: rgba(0, 0, 0, 0.45);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 16px;
        text-align: center;
        box-shadow:
          0 12px 40px rgba(0, 0, 0, 0.45),
          inset 0 0 0 1px rgba(255, 255, 255, 0.04);
      }
      .title {
        font-size: 28px;
        font-weight: 900;
        margin: 4px 0 8px;
        letter-spacing: 0.6px;
        text-transform: uppercase;
      }
      .subtitle {
        opacity: 0.85;
        font-size: 14px;
        margin-bottom: 16px;
      }
      .btn {
        display: inline-block;
        margin-top: 10px;
        padding: 14px 18px;
        min-width: 200px;
        border-radius: 12px;
        border: none;
        font-size: 16px;
        font-weight: 800;
        letter-spacing: 0.6px;
        color: #0b0f1a;
        background: linear-gradient(180deg, #94f7b7 0%, #3ee686 100%);
        box-shadow: 0 8px 20px rgba(62, 230, 134, 0.35);
        cursor: pointer;
      }
      .btn:active {
        transform: translateY(1px);
      }
      .gesture-hint {
        position: fixed;
        bottom: calc(16px + var(--ui-safe));
        left: 50%;
        transform: translateX(-50%);
        opacity: 0.7;
        font-size: 12px;
        background: rgba(0, 0, 0, 0.35);
        padding: 8px 12px;
        border-radius: 12px;
        user-select: none;
      }
      .config-hint {
        margin-top: 10px;
        font-size: 12px;
        opacity: 0.8;
      }
    </style>
  </head>
  <body>
    <div class="hud" id="hud">
      <div><span id="scoreLabel">Score</span>: <span id="score">0</span></div>
      <div>| <span id="bestLabel">Best</span>: <span id="best">0</span></div>
    </div>

    <div id="wrap"><canvas id="canvas"></canvas></div>

    <div class="overlay" id="overlay" style="display: none">
      <div class="panel">
        <div class="title" id="gameTitle">Eat & Grow</div>
        <div class="subtitle" id="subtitle">Collect the food, don’t hit walls or your tail!</div>
        <div class="instructions" style="text-align:left; margin: 10px auto 0; max-width: 420px; line-height:1.35; font-size:13px; opacity:0.92">
          <div id="howTitle" style="font-weight:800; letter-spacing:0.3px; margin-bottom:6px;">How to Play</div>
          <ul id="howList" style="margin:6px 0 10px 18px; padding:0;">
            <li>Controls: Swipe (mobile) • Arrow Keys (desktop)</li>
            <li>Top dark area is a no-play zone — food never spawns there. Depending on settings it acts as wrap or a wall.</li>
          </ul>
          <div id="itemsTitle" style="font-weight:800; letter-spacing:0.3px; margin-bottom:6px;">Items</div>
          <ul id="itemsList" style="margin:6px 0 0 18px; padding:0;">
            <li>Heart: +Score, slightly increases your speed</li>
            <li>Burger: +Score, slightly increases your speed</li>
          </ul>
        </div>
        <button class="btn" id="startBtn">Play</button>
        <div class="config-hint" id="controlsHint">Controls: Swipe (mobile) • Arrow Keys (desktop)</div>
      </div>
    </div>

    <div class="overlay" id="gameOver" style="display: none">
      <div class="panel">
        <div class="title" id="gameOverTitle">Game Over</div>
        <div class="subtitle">Score: <span id="finalScore">0</span></div>
        <button class="btn" id="againBtn">Play Again</button>
      </div>
    </div>

    <div class="gesture-hint" id="hint">Swipe to steer</div>

    <script id="game-assets" type="application/json">
      {
        "sounds": { "eat": "", "hit": "" },
        "_meta": {
          "sounds.eat": { "label": "Eat SFX", "category": "Sound Effects" },
          "sounds.hit": { "label": "Hit SFX", "category": "Sound Effects" }
        }
      }
    </script>
    
    <script>
      function deepMerge(target, source) {
        if (!source || typeof source !== "object") return target;
        const out = Array.isArray(target) ? target.slice() : { ...(target || {}) };
        for (const key of Object.keys(source)) {
          const sv = source[key];
          const tv = out[key];
          if (sv && typeof sv === "object" && !Array.isArray(sv)) {
            out[key] = deepMerge(tv || {}, sv);
          } else if (Array.isArray(sv)) {
            out[key] = sv.slice();
          } else {
            out[key] = sv;
          }
        }
        return out;
      }

      let CONFIG = {};

      let sdkListenersAttached = false;
      function tryHaptic() {
        try { window.FarcadeSDK?.singlePlayer?.actions?.hapticFeedback?.(); } catch (e) {}
      }
      function tryReady() {
        try { window.FarcadeSDK?.singlePlayer?.actions?.ready?.(); } catch (e) {}
      }
      function tryGameOver(score) {
        try { window.FarcadeSDK?.singlePlayer?.actions?.gameOver?.({ score }); } catch (e) {}
      }
      function attachSDKListeners() {
        if (sdkListenersAttached) return;
        if (window.FarcadeSDK?.on) {
          window.FarcadeSDK.on("play_again", () => {
            resetGame();
            showStart();
          });
          window.FarcadeSDK.on("toggle_mute", (data) => {
            isMuted = data.isMuted;
            AudioMgr.setMute(isMuted);
          });
          sdkListenersAttached = true;
        }
      }

      async function initConfig() {
        try {
          const response = await fetch("/api/game-config?format=full&t=" + new Date().getTime());
          if (!response.ok) {
            throw new Error("Config API not found");
          }
          const externalConfig = await response.json();
          console.log("Loaded external config:", externalConfig);
          
          CONFIG = externalConfig;
          applyUIFromConfig();

        } catch (error) {
          console.error("Could not load external config, using default.", error);
          CONFIG = {
            colors: { background: "#0052FF", snakeHead: "#dfb4b4", foodPrimary: "#e1ff00", grid: "#1c60f2", snakeBody: "#ffffff", foodSecondary: "#fff700", particle: "#ffffff", ui: "#ffffff", noPlay: "#06103a" },
            player: { baseSpeed: 6, speedIncreasePerFood: 0.6, minStepMs: 140, roundedHead: 0.39, roundedBody: 0.1 },
            gameplay: { gridSize: 30, columns: 20, rows: 28, wrapWalls: true, startLength: 7, foodScore: 30, particles: true, foodShape: "heart", foodKind: "burger", topNoPlayRows: 3, noPlayActsAs: "wrap" },
            ui: { showGrid: false, showSwipeHint: false, interfaceTitle: "Eat & Grow" },
            typography: { fontFamily: "system-ui", titleSize: 28, titleWeight: 900, subtitleSize: 14, buttonSize: 16, buttonWeight: 800, hudSize: 14 },
            buttons: { primaryColor: "#3ee686", primaryGradientStart: "#94f7b7", primaryGradientEnd: "#3ee686", textColor: "#0b0f1a", borderRadius: 12, shadow: true },
            sounds: { enabled: true, eatSound: true, hitSound: true, volume: 0.5 },
            startScreen: {
              title: "Eat & Grow",
              subtitle: "Collect the food, don’t hit walls or your tail!",
              howToPlayTitle: "How to Play",
              howToPlayItems: [
                "Controls: Swipe (mobile) • Arrow Keys (desktop)",
                "Top dark area is a no-play zone — food never spawns there. Depending on settings it acts as wrap or a wall."
              ],
              itemsTitle: "Items",
              itemsList: [
                "Heart: +Score, slightly increases your speed",
                "Burger: +Score, slightly increases your speed"
              ],
              startButtonLabel: "Play",
              playAgainLabel: "Play Again",
              gameOverTitle: "Game Over",
              controlsHint: "Controls: Swipe (mobile) • Arrow Keys (desktop)",
              scoreLabel: "Score",
              bestLabel: "Best",
              hudFontSize: 14,
              hudFontWeight: 700,
              hudBackground: "rgba(0, 0, 0, 0.35)",
              hudBorderRadius: 12
            },
            difficulty: "normal"
          };
        }

        applyUIFromConfig();

        window.addEventListener("message", (event) => {
          if (event.origin !== window.location.origin) return;
          if (event.data && event.data.type === "UPDATE_CONFIG") {
            CONFIG = deepMerge(CONFIG, event.data.config);
            applyUIFromConfig();
            if (window.onConfigUpdate) window.onConfigUpdate(CONFIG);
          }
        });
      }

      let ASSETS = {};
      const loadedImages = {};
      const loadedSounds = {};
      function initAssets() {
        ASSETS = JSON.parse(document.getElementById("game-assets").textContent);
        window.addEventListener("message", (event) => {
          if (event.origin !== window.location.origin) return;
          if (event.data && event.data.type === "UPDATE_ASSETS") {
            ASSETS = event.data.assets;
            reloadAssets();
          }
        });
        loadAssets();
      }
      function loadAssets() {
        if (ASSETS.sounds?.eat) loadedSounds.eat = new Audio(ASSETS.sounds.eat);
        if (ASSETS.sounds?.hit) loadedSounds.hit = new Audio(ASSETS.sounds.hit);
      }
      function reloadAssets() {
        if (ASSETS.sounds?.eat && loadedSounds.eat) loadedSounds.eat.src = ASSETS.sounds.eat;
        if (ASSETS.sounds?.hit && loadedSounds.hit) loadedSounds.hit.src = ASSETS.sounds.hit;
      }

      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const hudScore = document.getElementById("score");
      const hudBest = document.getElementById("best");
      const hudScoreLabel = document.getElementById("scoreLabel");
      const hudBestLabel = document.getElementById("bestLabel");
      const hudEl = document.getElementById("hud");
      const overlay = document.getElementById("overlay");
      const gameOverEl = document.getElementById("gameOver");
      const finalScoreEl = document.getElementById("finalScore");
      const startBtn = document.getElementById("startBtn");
      const againBtn = document.getElementById("againBtn");
      const hintEl = document.getElementById("hint");
      const gameTitleEl = document.getElementById("gameTitle");
      const subtitleEl = document.getElementById("subtitle");
      const howTitleEl = document.getElementById("howTitle");
      const howListEl = document.getElementById("howList");
      const itemsTitleEl = document.getElementById("itemsTitle");
      const itemsListEl = document.getElementById("itemsList");
      const controlsHintEl = document.getElementById("controlsHint");
      const gameOverTitleEl = document.getElementById("gameOverTitle");

      let isMuted = false;

      const state = {
        gameState: "start",
        tAccum: 0,
        lastTime: 0,
        stepMs: 120,
        gridSize: 30,
        cols: 20,
        rows: 28,
        snake: [],
        dir: { x: 1, y: 0 },
        nextDir: { x: 1, y: 0 },
        food: { x: 10, y: 10 },
        score: 0,
        best: Number(localStorage.getItem("eatgrow_best") || 0),
        particles: [],
      };

      function applyDifficulty() {
        const base = CONFIG.player.baseSpeed;
        const diff = CONFIG.difficulty;
        let speed = base;
        if (diff === "easy") speed = base * 0.85;
        if (diff === "hard") speed = base * 1.2;
        state.stepMs = Math.max(1000 / speed, CONFIG.player.minStepMs);
      }

      function resizeCanvas() {
        canvas.width = state.cols * state.gridSize;
        canvas.height = state.rows * state.gridSize;
      }

      function applyUIFromConfig() {
        // Title and subtitles
        gameTitleEl.textContent = CONFIG.ui?.interfaceTitle || (CONFIG.startScreen?.title) || "Eat & Grow";
        if (subtitleEl) subtitleEl.textContent = (CONFIG.startScreen?.subtitle) || "Collect the food, don’t hit walls or your tail!";
        if (howTitleEl) howTitleEl.textContent = (CONFIG.startScreen?.howToPlayTitle) || "How to Play";
        if (howListEl) {
          howListEl.innerHTML = (CONFIG.startScreen?.howToPlayItems || [
            "Controls: Swipe (mobile) • Arrow Keys (desktop)",
            "Top dark area is a no-play zone — food never spawns there. Depending on settings it acts as wrap or a wall."
          ]).map((t) => `<li>${t}</li>`).join("");
        }
        if (itemsTitleEl) itemsTitleEl.textContent = (CONFIG.startScreen?.itemsTitle) || "Items";
        if (itemsListEl) {
          itemsListEl.innerHTML = (CONFIG.startScreen?.itemsList || [
            "Heart: +Score, slightly increases your speed",
            "Burger: +Score, slightly increases your speed"
          ]).map((t) => `<li>${t}</li>`).join("");
        }
        if (controlsHintEl) controlsHintEl.textContent = (CONFIG.startScreen?.controlsHint) || "Controls: Swipe (mobile) • Arrow Keys (desktop)";
        if (startBtn) startBtn.textContent = (CONFIG.startScreen?.startButtonLabel) || "Play";
        if (againBtn) againBtn.textContent = (CONFIG.startScreen?.playAgainLabel) || "Play Again";
        if (gameOverTitleEl) gameOverTitleEl.textContent = (CONFIG.startScreen?.gameOverTitle) || "Game Over";

        // HUD labels and styles
        if (hudScoreLabel) hudScoreLabel.textContent = (CONFIG.startScreen?.scoreLabel) || "Score";
        if (hudBestLabel) hudBestLabel.textContent = (CONFIG.startScreen?.bestLabel) || "Best";
        if (hudEl) {
          hudEl.style.fontSize = (CONFIG.startScreen?.hudFontSize ?? 14) + 'px';
          hudEl.style.fontWeight = (CONFIG.startScreen?.hudFontWeight ?? 700).toString();
          hudEl.style.background = CONFIG.startScreen?.hudBackground || 'rgba(0, 0, 0, 0.35)';
          hudEl.style.borderRadius = (CONFIG.startScreen?.hudBorderRadius ?? 12) + 'px';
        }

        // Button styles from config
        const btnBg = `linear-gradient(180deg, ${CONFIG.buttons?.primaryGradientStart || '#94f7b7'} 0%, ${CONFIG.buttons?.primaryGradientEnd || '#3ee686'} 100%)`;
        const btnColor = CONFIG.buttons?.textColor || '#0b0f1a';
        const radius = (CONFIG.buttons?.borderRadius ?? 12) + 'px';
        const shadow = CONFIG.buttons?.shadow ? '0 8px 20px rgba(62, 230, 134, 0.35)' : 'none';
        [startBtn, againBtn].forEach((btn) => {
          if (!btn) return;
          btn.style.background = btnBg;
          btn.style.color = btnColor;
          btn.style.borderRadius = radius;
          btn.style.boxShadow = shadow;
          btn.style.fontSize = (CONFIG.typography?.buttonSize ?? 16) + 'px';
          btn.style.fontWeight = (CONFIG.typography?.buttonWeight ?? 800).toString();
        });

        // Typography
        document.querySelectorAll('.title').forEach((el) => {
          el.style.fontSize = (CONFIG.typography?.titleSize ?? 28) + 'px';
          el.style.fontWeight = (CONFIG.typography?.titleWeight ?? 900).toString();
          el.style.fontFamily = (CONFIG.typography?.fontFamily || 'system-ui');
        });
        document.querySelectorAll('.subtitle').forEach((el) => {
          el.style.fontFamily = (CONFIG.typography?.fontFamily || 'system-ui');
        });
      }

      function resetGame() {
        state.gridSize = CONFIG.gameplay.gridSize;
        state.cols = CONFIG.gameplay.columns;
        state.rows = CONFIG.gameplay.rows;
        gameTitleEl.textContent = CONFIG.ui.interfaceTitle;
        state.snake = [];
        const startLen = CONFIG.gameplay.startLength;
        const startX = Math.floor(state.cols / 2);
        const topRows = CONFIG.gameplay.topNoPlayRows || 0;
        const startY = Math.max(topRows + 1, Math.floor(state.rows / 2));
        for (let i = 0; i < startLen; i++) {
          state.snake.push({ x: startX - i, y: startY });
        }
        state.dir = { x: 1, y: 0 };
        state.nextDir = { x: 1, y: 0 };
        state.score = 0;
        hudScore.textContent = "0";
        placeFood();
        state.particles = [];
        applyDifficulty();
        resizeCanvas();
        hintEl.style.display = CONFIG.ui.showSwipeHint ? "block" : "none";
      }

      function cellInTopNoPlay(y) {
        const topRows = CONFIG.gameplay.topNoPlayRows || 0;
        return y >= 0 && y < topRows;
      }

      function placeFood() {
        const topRows = CONFIG.gameplay.topNoPlayRows || 0;
        while (true) {
          const x = Math.floor(Math.random() * state.cols);
          const y = Math.floor(Math.random() * state.rows);
          if (y < topRows) continue;
          if (!state.snake.some((s) => s.x === x && s.y === y)) {
            state.food = { x, y };
            break;
          }
        }
      }

      function drawGrid() {
        if (!CONFIG.ui.showGrid) return;
        ctx.strokeStyle = CONFIG.colors.grid;
        ctx.lineWidth = 1;
        for (let x = 0; x <= state.cols; x++) {
          ctx.beginPath();
          ctx.moveTo(x * state.gridSize + 0.5, 0);
          ctx.lineTo(x * state.gridSize + 0.5, canvas.height);
          ctx.stroke();
        }
        for (let y = 0; y <= state.rows; y++) {
          ctx.beginPath();
          ctx.moveTo(0, y * state.gridSize + 0.5);
          ctx.lineTo(canvas.width, y * state.gridSize + 0.5);
          ctx.stroke();
        }
      }

      function drawTopNoPlayZone() {
        const topRows = CONFIG.gameplay.topNoPlayRows || 0;
        if (!topRows) return;
        const h = topRows * state.gridSize;
        ctx.save();
        ctx.globalAlpha = 0.35;
        ctx.fillStyle = CONFIG.colors.noPlay || "#06103a";
        ctx.fillRect(0, 0, canvas.width, h);
        ctx.globalAlpha = 1;
        ctx.strokeStyle = hexToRgba(CONFIG.colors.ui || "#ffffff", 0.25);
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, h + 0.5);
        ctx.lineTo(canvas.width, h + 0.5);
        ctx.stroke();
        ctx.restore();
      }

      function drawRoundedCell(x, y, color, radiusFrac = 0.25) {
        const gs = state.gridSize;
        const px = x * gs, py = y * gs;
        const r = gs * radiusFrac;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(px + r, py);
        ctx.arcTo(px + gs, py, px + gs, py + gs, r);
        ctx.arcTo(px + gs, py + gs, px, py + gs, r);
        ctx.arcTo(px, py + gs, px, py, r);
        ctx.arcTo(px, py, px + gs, py, r);
        ctx.closePath();
        ctx.fill();
      }

      function addParticles(x, y, color) {
        if (!CONFIG.gameplay.particles) return;
        for (let i = 0; i < 8; i++) {
          state.particles.push({
            x: x * state.gridSize + state.gridSize / 2,
            y: y * state.gridSize + state.gridSize / 2,
            vx: (Math.random() - 0.5) * 2.2,
            vy: (Math.random() - 0.5) * 2.2,
            life: 18 + Math.random() * 10,
            color,
          });
        }
      }
      function updateParticles() {
        for (const p of state.particles) {
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.02;
          p.life -= 1;
        }
        state.particles = state.particles.filter((p) => p.life > 0);
      }
      function drawParticles() {
        for (const p of state.particles) {
          const alpha = Math.max(0, Math.min(1, p.life / 20));
          ctx.fillStyle = hexToRgba(CONFIG.colors.particle, alpha);
          ctx.fillRect(p.x - 1.5, p.y - 1.5, 3, 3);
        }
      }

      function hexToRgba(hex, a = 1) {
        const h = hex.replace("#", "");
        const bigint = parseInt(h, 16);
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = bigint & 255;
        return `rgba(${r},${g},${b},${a})`;
      }

      const AudioMgr = {
        ctx: null,
        gain: null,
        init() {
          if (this.ctx) return;
          try {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.gain = this.ctx.createGain();
            this.gain.connect(this.ctx.destination);
            this.setMute(isMuted);
          } catch (e) {}
        },
        setMute(m) {
          isMuted = !!m;
          if (!this.gain) return;
          this.gain.gain.value = isMuted ? 0 : 0.9;
        },
        tone(freq = 440, dur = 0.08, type = "sine") {
          if (!this.ctx) return;
          const o = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          o.type = type;
          o.frequency.value = freq;
          o.connect(g);
          g.connect(this.gain);
          const t = this.ctx.currentTime;
          g.gain.setValueAtTime(0.0001, t);
          g.gain.exponentialRampToValueAtTime(0.4, t + 0.01);
          g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
          o.start();
          o.stop(t + dur + 0.02);
        },
        play(name) {
          if (isMuted) return;
          if (loadedSounds[name]) {
            loadedSounds[name].currentTime = 0;
            loadedSounds[name].play();
          } else {
            if (name === "eat") this.tone(680, 0.07, "triangle");
            if (name === "hit") this.tone(140, 0.18, "square");
          }
        },
      };

      let touchStart = null;
      function onTouchStart(e) {
        AudioMgr.init();
        const t = e.touches[0];
        touchStart = { x: t.clientX, y: t.clientY, time: performance.now() };
      }
      function onTouchMove(e) {
        e.preventDefault();
      }
      function onTouchEnd(e) {
        if (!touchStart) return;
        const t = e.changedTouches[0];
        const dx = t.clientX - touchStart.x;
        const dy = t.clientY - touchStart.y;
        const ax = Math.abs(dx), ay = Math.abs(dy);
        if (ax < 12 && ay < 12) {
          touchStart = null;
          return;
        }
        if (ax > ay) {
          if (dx > 0) setDir(1, 0);
          else setDir(-1, 0);
        } else {
          if (dy > 0) setDir(0, 1);
          else setDir(0, -1);
        }
        tryHaptic();
        touchStart = null;
        hintEl.style.display = "none";
      }
      function onKey(e) {
        if (e.key === "ArrowUp") setDir(0, -1);
        if (e.key === "ArrowDown") setDir(0, 1);
        if (e.key === "ArrowLeft") setDir(-1, 0);
        if (e.key === "ArrowRight") setDir(1, 0);
        if (e.key === " ") startGame();
        if (e.key === "Enter") startGame();
      }
      function setDir(x, y) {
        if (state.dir.x === -x && state.dir.y === -y) return;
        state.nextDir = { x, y };
      }

      function step() {
        state.dir = state.nextDir;
        let head = { x: state.snake[0].x + state.dir.x, y: state.snake[0].y + state.dir.y };

        const wrap = CONFIG.gameplay.wrapWalls;
        const topRows = CONFIG.gameplay.topNoPlayRows || 0;
        const noPlayMode = CONFIG.gameplay.noPlayActsAs || "wrap";

        if (wrap) {
          head.x = (head.x + state.cols) % state.cols;
        } else {
          if (head.x < 0 || head.x >= state.cols) return die();
        }

        if (!wrap) {
          if (head.y < 0 || head.y >= state.rows) return die();
        } else {
          if (head.y < 0) {
            head.y = state.rows - 1;
          } else if (head.y >= state.rows) {
            head.y = 0;
          }
        }

        if (cellInTopNoPlay(head.y)) {
          if (noPlayMode === "wall") {
            return die();
          } else {
            head.y = topRows;
            if (state.dir.y < 0 || head.y < topRows) {
              head.y = state.rows - 1;
            }
            if (cellInTopNoPlay(head.y)) head.y = topRows;
          }
        }

        if (state.snake.some((s) => s.x === head.x && s.y === head.y)) return die();

        state.snake.unshift(head);
        if (head.x === state.food.x && head.y === state.food.y) {
          state.score += CONFIG.gameplay.foodScore;
          hudScore.textContent = state.score;
          addParticles(head.x, head.y, CONFIG.colors.particle);
          AudioMgr.play("eat");
          tryHaptic();
          const ms = state.stepMs;
          const delta =
            1000 / (CONFIG.player.baseSpeed + CONFIG.player.speedIncreasePerFood) - 1000 / CONFIG.player.baseSpeed;
          state.stepMs = Math.max(ms - (delta || 0.5), CONFIG.player.minStepMs);
          placeFood();
        } else {
          state.snake.pop();
        }
      }

      function die() {
        AudioMgr.play("hit");
        tryHaptic();
        state.gameState = "gameover";
        finalScoreEl.textContent = state.score;
        if (state.score > state.best) {
          state.best = state.score;
          localStorage.setItem("eatgrow_best", String(state.best));
        }
        hudBest.textContent = state.best;
        showGameOver();
        tryGameOver(state.score);
      }

      function drawFoodIcon(kind, cx, cy, size) {
        ctx.save();
        if (kind === "heart") {
          const s = size;
          const r = s * 0.25;
          ctx.translate(cx, cy);
          ctx.fillStyle = CONFIG.colors.foodPrimary;
          ctx.beginPath();
          ctx.moveTo(0, s * 0.28);
          ctx.bezierCurveTo(-s * 0.5, -s * 0.1, -s * 0.52, -s * 0.55, -s * 0.22, -s * 0.62);
          ctx.bezierCurveTo(-s * 0.02, -s * 0.66, s * 0.12, -s * 0.54, 0, -s * 0.4);
          ctx.bezierCurveTo(s * 0.12, -s * 0.54, s * 0.02, -s * 0.66, s * 0.22, -s * 0.62);
          ctx.bezierCurveTo(s * 0.52, -s * 0.55, s * 0.5, -s * 0.1, 0, s * 0.28);
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = hexToRgba("#ffffff", 0.25);
          ctx.beginPath();
          ctx.ellipse(-s * 0.12, -s * 0.42, r, r * 0.7, -0.6, 0, Math.PI * 2);
          ctx.fill();
        } else if (kind === "burger") {
          const s = size;
          ctx.translate(cx, cy);
          ctx.fillStyle = CONFIG.colors.foodSecondary;
          ctx.beginPath();
          ctx.roundRect(-s * 0.5, -s * 0.46, s, s * 0.38, s * 0.2);
          ctx.fill();
          ctx.fillStyle = "#38d17a";
          ctx.fillRect(-s * 0.45, -s * 0.12, s * 0.9, s * 0.08);
          ctx.fillStyle = "#6b3e2e";
          ctx.fillRect(-s * 0.46, -s * 0.04, s * 0.92, s * 0.1);
          ctx.fillStyle = "#ffcf33";
          ctx.fillRect(-s * 0.3, 0.06 * s, s * 0.6, s * 0.08);
          ctx.fillStyle = CONFIG.colors.foodSecondary;
          ctx.beginPath();
          ctx.roundRect(-s * 0.5, s * 0.12, s, s * 0.26, s * 0.12);
          ctx.fill();
        }
        ctx.restore();
      }

      function draw() {
        ctx.fillStyle = CONFIG.colors.background;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawTopNoPlayZone();
        drawGrid();
        const pulse = (performance.now() / 600) % 1;
        const scale = 0.8 + Math.sin(pulse * 2 * Math.PI) * 0.05;
        const s = state.gridSize * scale;
        const fx = state.food.x * state.gridSize + state.gridSize / 2;
        const fy = state.food.y * state.gridSize + state.gridSize / 2;
        const kind = CONFIG.gameplay.foodShape === "auto" ? CONFIG.gameplay.foodKind : CONFIG.gameplay.foodShape;
        drawFoodIcon((kind === "circle" || kind === "square") ? "heart" : kind, fx, fy, s * 0.8);
        if (kind === "square") {
          ctx.fillStyle = CONFIG.colors.foodPrimary;
          ctx.beginPath();
          ctx.roundRect(fx - s * 0.4, fy - s * 0.4, s * 0.8, s * 0.8, 6);
          ctx.fill();
        }
        if (kind === "circle") {
          ctx.fillStyle = CONFIG.colors.foodPrimary;
          ctx.beginPath();
          ctx.arc(fx, fy, s * 0.36, 0, Math.PI * 2);
          ctx.fill();
        }
        for (let i = state.snake.length - 1; i >= 0; i--) {
          const seg = state.snake[i];
          const color = i === 0 ? CONFIG.colors.snakeHead : CONFIG.colors.snakeBody;
          const roundFrac = i === 0 ? CONFIG.player.roundedHead : CONFIG.player.roundedBody;
          drawRoundedCell(seg.x, seg.y, color, roundFrac);
        }
        drawParticles();
      }

      function loop(ts) {
        if (!state.lastTime) state.lastTime = ts;
        const dt = ts - state.lastTime;
        state.lastTime = ts;
        if (state.gameState === "playing") {
          state.tAccum += dt;
          while (state.tAccum >= state.stepMs) {
            step();
            state.tAccum -= state.stepMs;
          }
          updateParticles();
          draw();
        } else if (state.gameState === "start") {
          draw();
        }
        requestAnimationFrame(loop);
      }

      function showStart() {
        overlay.style.display = "grid";
        gameOverEl.style.display = "none";
      }
      function showGameOver() {
        overlay.style.display = "none";
        gameOverEl.style.display = "grid";
      }

      function startGame() {
        if (state.gameState === "playing") return;
        AudioMgr.init();
        state.gameState = "playing";
        overlay.style.display = "none";
        gameOverEl.style.display = "none";
        if (CONFIG.ui.showSwipeHint) hintEl.style.display = "block";
      }

      window.onConfigUpdate = (cfg) => {
        canvas.style.backgroundColor = cfg.colors.background;
        gameTitleEl.textContent = cfg.ui.interfaceTitle;
        applyDifficulty();
      };

      async function main() {
        await initConfig();
        initAssets();
        canvas.style.backgroundColor = CONFIG.colors.background;
        gameTitleEl.textContent = CONFIG.ui.interfaceTitle;
        hudBest.textContent = state.best;
        applyDifficulty();
        resetGame();
        showStart();
        tryReady();
        attachSDKListeners();
        const sdkPoll = setInterval(() => {
          if (!sdkListenersAttached) attachSDKListeners();
          else clearInterval(sdkPoll);
        }, 300);
        setTimeout(() => clearInterval(sdkPoll), 5000);

        window.addEventListener("keydown", onKey);
        window.addEventListener("resize", resizeCanvas);
        canvas.addEventListener("touchstart", onTouchStart, { passive: false });
        canvas.addEventListener("touchmove", onTouchMove, { passive: false });
        canvas.addEventListener("touchend", onTouchEnd);
        startBtn.addEventListener("click", () => {
          resetGame();
          startGame();
        });
        againBtn.addEventListener("click", () => {
          resetGame();
          startGame();
        });
        requestAnimationFrame(loop);
      }

      if (!CanvasRenderingContext2D.prototype.roundRect) {
        CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
          if (w < 2 * r) r = w / 2;
          if (h < 2 * r) r = h / 2;
          this.beginPath();
          this.moveTo(x + r, y);
          this.arcTo(x + w, y, x + w, y + h, r);
          this.arcTo(x + w, y + h, x, y + h, r);
          this.arcTo(x, y + h, x, y, r);
          this.arcTo(x, y, x + w, y, r);
          this.closePath();
          return this;
        };
      }

      main();
    </script>
  </body>
</html>
