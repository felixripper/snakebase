<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <!-- viewport-fit=cover eklendi -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <title>Eat & Grow</title>
    <script src="https://cdn.jsdelivr.net/npm/@farcade/game-sdk@0.2.1/dist/index.min.js"></script>
    <style>
      :root {
        --ui-safe: env(safe-area-inset-bottom, 0px);
      }
      html,
      body {
        margin: 0;
        padding: 0;
        /* Daha stabil görünüm için vh fallback + overscroll kapalı */
        height: 100vh;
        width: 100vw;
        background: #0b0f1a;
        overflow: hidden;
        touch-action: none;
        -webkit-tap-highlight-color: transparent;
        overscroll-behavior: none;
        font-family:
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Helvetica,
          Arial,
          sans-serif;
        color: #fff;
      }
      /* Destek varsa sabit viewport birimlerine geç */
      @supports (height: 100svh) {
        html,
        body {
          height: 100svh;
        }
      }

      .hud {
        position: fixed;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 12px;
        padding: 8px 12px;
        background: rgba(0, 0, 0, 0.35);
        backdrop-filter: blur(6px);
        border-radius: 12px;
        font-weight: 700;
        letter-spacing: 0.4px;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.35);
        user-select: none;
        pointer-events: none;
        z-index: 5;
      }
      #wrap {
        position: fixed;
        inset: 0;
        display: grid;
        place-items: center;
      }
      /* Canvas: 2:3 oranını korurken stabil viewport birimlerini kullan */
      #canvas {
        /* Fallback (vh) */
        width: min(100vw, 66.666vh);
        height: calc(min(100vw, 66.666vh) * 1.5);
        image-rendering: pixelated;
        image-rendering: crisp-edges;
        border-radius: 16px;
        box-shadow:
          0 10px 40px rgba(0, 0, 0, 0.5),
          inset 0 0 0 2px rgba(255, 255, 255, 0.06);
        background: radial-gradient(120% 120% at 50% 0%, #0b1228 0%, #070b18 60%, #05070f 100%);
        max-height: 100vh;
        max-width: 100vw;
      }
      /* Destek varsa svh ile override */
      @supports (height: 100svh) {
        #canvas {
          width: min(100vw, 66.666svh);
          height: calc(min(100vw, 66.666svh) * 1.5);
          max-height: 100svh;
          max-width: 100vw;
        }
      }

      .overlay {
        position: fixed;
        inset: 0;
        display: grid;
        place-items: center;
        background: linear-gradient(to bottom right, rgba(5, 8, 20, 0.75), rgba(5, 8, 16, 0.85));
        backdrop-filter: blur(4px);
      }
      .panel {
        width: min(92vw, 460px);
        padding: 20px 18px 16px;
        background: rgba(0, 0, 0, 0.45);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 16px;
        text-align: center;
        box-shadow:
          0 12px 40px rgba(0, 0, 0, 0.45),
          inset 0 0 0 1px rgba(255, 255, 255, 0.04);
      }
      .panel.show {
        animation: popIn 260ms cubic-bezier(.2,.9,.2,1);
      }
      @keyframes popIn {
        from { transform: scale(.92); opacity: 0; }
        to { transform: scale(1); opacity: 1; }
      }
      .title {
        font-size: 28px;
        font-weight: 900;
        margin: 4px 0 8px;
        letter-spacing: 0.6px;
        text-transform: uppercase;
      }
      .subtitle {
        opacity: 0.85;
        font-size: 14px;
        margin-bottom: 16px;
      }
      .btn {
        display: inline-block;
        margin-top: 10px;
        padding: 12px 18px;
        min-width: 160px;
        border-radius: 12px;
        border: none;
        font-size: 16px;
        font-weight: 800;
        letter-spacing: 0.6px;
        color: #0b0f1a;
        background: linear-gradient(180deg, #94f7b7 0%, #3ee686 100%);
        box-shadow: 0 8px 20px rgba(62, 230, 134, 0.35);
        cursor: pointer;
      }
      .btn:active {
        transform: translateY(1px);
      }
      @media (max-width: 520px) {
        .panel { width: calc(100vw - 32px); padding: 16px; }
        .btn { min-width: 140px; padding: 12px 14px; font-size: 15px; }
      }
      .gesture-hint {
        position: fixed;
        bottom: calc(16px + var(--ui-safe));
        left: 50%;
        transform: translateX(-50%);
        opacity: 0.7;
        font-size: 12px;
        background: rgba(0, 0, 0, 0.35);
        padding: 8px 12px;
        border-radius: 12px;
        user-select: none;
      }
      .config-hint {
        margin-top: 10px;
        font-size: 12px;
        opacity: 0.8;
      }
    </style>
  </head>
  <body>
    <script>
      // Game configuration and asset management
      let CONFIG = {};

      async function initConfig() {
        try {
          const response = await fetch('/api/game-config?format=full');
          CONFIG = await response.json();
        } catch (error) {
          console.error('Failed to load config:', error);
          // Fallback config
          CONFIG = {
            startScreen: {
              hudFontWeight: 700,
              hudBackground: "rgba(0, 0, 0, 0.35)",
              hudBorderRadius: 12
            },
            difficulty: "normal"
          };
        }
        applyUIFromConfig();
        window.addEventListener("message", (event) => {
          if (event.origin !== window.location.origin) return;
          if (event.data && event.data.type === "UPDATE_CONFIG") {
            CONFIG = deepMerge(CONFIG, event.data.config);
            applyUIFromConfig();
            if (window.onConfigUpdate) window.onConfigUpdate(CONFIG);
          }
        });
      }
      // Asset management
      let ASSETS = {};
      const loadedImages = {};
      const loadedSounds = {};
      function initAssets() {
        ASSETS = JSON.parse(document.getElementById("game-assets").textContent);
        window.addEventListener("message", (event) => {
          if (event.origin !== window.location.origin) return;
          if (event.data && event.data.type === "UPDATE_ASSETS") {
            ASSETS = event.data.assets;
            reloadAssets();
          }
        });
        loadAssets();
      }
      function loadAssets() {
        if (ASSETS.sounds?.eat) loadedSounds.eat = new Audio(ASSETS.sounds.eat);
        if (ASSETS.sounds?.hit) loadedSounds.hit = new Audio(ASSETS.sounds.hit);
      }
      function reloadAssets() {
        if (ASSETS.sounds?.eat && loadedSounds.eat) loadedSounds.eat.src = ASSETS.sounds.eat;
        if (ASSETS.sounds?.hit && loadedSounds.hit) loadedSounds.hit.src = ASSETS.sounds.hit;
      }

      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const hudScore = document.getElementById("score");
      const hudBest = document.getElementById("best");
      const hudScoreLabel = document.getElementById("scoreLabel");
      const hudBestLabel = document.getElementById("bestLabel");
      const hudEl = document.getElementById("hud");
      const overlay = document.getElementById("overlay");
      const gameOverEl = document.getElementById("gameOver");
      const finalScoreEl = document.getElementById("finalScore");
      const startBtn = document.getElementById("startBtn");
      const againBtn = document.getElementById("againBtn");
      const hintEl = document.getElementById("hint");
      const gameTitleEl = document.getElementById("gameTitle");
      const subtitleEl = document.getElementById("subtitle");
      const howTitleEl = document.getElementById("howTitle");
      const howListEl = document.getElementById("howList");
      const itemsTitleEl = document.getElementById("itemsTitle");
      const itemsListEl = document.getElementById("itemsList");
      const controlsHintEl = document.getElementById("controlsHint");
      const gameOverTitleEl = document.getElementById("gameOverTitle");

      let isMuted = false;

      const state = {
        gameState: "start",
        tAccum: 0,
        lastTime: 0,
        stepMs: 120,
        gridSize: 30,
        cols: 20,
        rows: 28,
        snake: [],
        dir: { x: 1, y: 0 },
        nextDir: { x: 1, y: 0 },
        food: { x: 10, y: 10 },
        score: 0,
        best: Number(localStorage.getItem("eatgrow_best") || 0),
        particles: [],
      };

      function applyDifficulty() {
        const base = CONFIG.player.baseSpeed;
        const diff = CONFIG.difficulty;
        let speed = base;
        if (diff === "easy") speed = base * 0.85;
        if (diff === "hard") speed = base * 1.2;
        state.stepMs = Math.max(1000 / speed, CONFIG.player.minStepMs);
      }

      function resizeCanvas() {
        canvas.width = state.cols * state.gridSize;
        canvas.height = state.rows * state.gridSize;
      }

      function applyUIFromConfig() {
                // Title and subtitles
        gameTitleEl.textContent = CONFIG.ui?.interfaceTitle || (CONFIG.startScreen?.title) || "Eat & Grow";
        if (subtitleEl) subtitleEl.textContent = (CONFIG.startScreen?.subtitle) || "Collect the food, don't hit walls or your tail!";
        if (howTitleEl) howTitleEl.textContent = (CONFIG.startScreen?.howToPlayTitle) || "How to Play";
        if (howListEl) {
          // Safe DOM manipulation - prevents XSS
          howListEl.innerHTML = '';
          const items = CONFIG.startScreen?.howToPlayItems || [
            "Controls: Swipe (mobile) • Arrow Keys (desktop)",
            "Top dark area is a no-play zone — food never spawns there. Depending on settings it acts as wrap or a wall."
          ];
          items.forEach((text) => {
            const li = document.createElement('li');
            li.textContent = text; // textContent prevents XSS
            howListEl.appendChild(li);
          });
        }
        if (itemsTitleEl) itemsTitleEl.textContent = (CONFIG.startScreen?.itemsTitle) || "Items";
        if (itemsListEl) {
          // Safe DOM manipulation - prevents XSS
          itemsListEl.innerHTML = '';
          const items = CONFIG.startScreen?.itemsList || [
            "Heart: +Score, slightly increases your speed",
            "Burger: +Score, slightly increases your speed"
          ];
          items.forEach((text) => {
            const li = document.createElement('li');
            li.textContent = text; // textContent prevents XSS
            itemsListEl.appendChild(li);
          });
        }
        if (controlsHintEl) controlsHintEl.textContent = (CONFIG.startScreen?.controlsHint) || "Controls: Swipe (mobile) • Arrow Keys (desktop)";
        if (startBtn) startBtn.textContent = (CONFIG.startScreen?.startButtonLabel) || "Play";
        if (againBtn) againBtn.textContent = (CONFIG.startScreen?.playAgainLabel) || "Play Again";
        if (gameOverTitleEl) gameOverTitleEl.textContent = (CONFIG.startScreen?.gameOverTitle) || "Game Over";

        // HUD labels and styles
        if (hudScoreLabel) hudScoreLabel.textContent = (CONFIG.startScreen?.scoreLabel) || "Score";
        if (hudBestLabel) hudBestLabel.textContent = (CONFIG.startScreen?.bestLabel) || "Best";
        if (hudEl) {
          hudEl.style.fontSize = (CONFIG.startScreen?.hudFontSize ?? 14) + 'px';
          hudEl.style.fontWeight = (CONFIG.startScreen?.hudFontWeight ?? 700).toString();
          hudEl.style.background = CONFIG.startScreen?.hudBackground || 'rgba(0, 0, 0, 0.35)';
          hudEl.style.borderRadius = (CONFIG.startScreen?.hudBorderRadius ?? 12) + 'px';
        }

        // Button styles from config
        const btnBg = `linear-gradient(180deg, ${CONFIG.buttons?.primaryGradientStart || '#94f7b7'} 0%, ${CONFIG.buttons?.primaryGradientEnd || '#3ee686'} 100%)`;
        const btnColor = CONFIG.buttons?.textColor || '#0b0f1a';
        const radius = (CONFIG.buttons?.borderRadius ?? 12) + 'px';
        const shadow = CONFIG.buttons?.shadow ? '0 8px 20px rgba(62, 230, 134, 0.35)' : 'none';
        [startBtn, againBtn].forEach((btn) => {
          if (!btn) return;
          btn.style.background = btnBg;
          btn.style.color = btnColor;
          btn.style.borderRadius = radius;
          btn.style.boxShadow = shadow;
          btn.style.fontSize = (CONFIG.typography?.buttonSize ?? 16) + 'px';
          btn.style.fontWeight = (CONFIG.typography?.buttonWeight ?? 800).toString();
        });

        // Typography
        document.querySelectorAll('.title').forEach((el) => {
          el.style.fontSize = (CONFIG.typography?.titleSize ?? 28) + 'px';
          el.style.fontWeight = (CONFIG.typography?.titleWeight ?? 900).toString();
          el.style.fontFamily = (CONFIG.typography?.fontFamily || 'system-ui');
        });
        document.querySelectorAll('.subtitle').forEach((el) => {
          el.style.fontFamily = (CONFIG.typography?.fontFamily || 'system-ui');
        });
      }

      function resetGame() {
        state.gridSize = CONFIG.gameplay.gridSize;
        state.cols = CONFIG.gameplay.columns;
        state.rows = CONFIG.gameplay.rows;
        gameTitleEl.textContent = CONFIG.ui.interfaceTitle;
        state.snake = [];
        const startLen = CONFIG.gameplay.startLength;
        const startX = Math.floor(state.cols / 2);
        const topRows = CONFIG.gameplay.topNoPlayRows || 0;
        const startY = Math.max(topRows + 1, Math.floor(state.rows / 2));
        for (let i = 0; i < startLen; i++) {
          state.snake.push({ x: startX - i, y: startY });
        }
        state.dir = { x: 1, y: 0 };
        state.nextDir = { x: 1, y: 0 };
        state.score = 0;
        hudScore.textContent = "0";
        placeFood();
        state.particles = [];
        applyDifficulty();
        resizeCanvas();
        hintEl.style.display = CONFIG.ui.showSwipeHint ? "block" : "none";
      }

      function cellInTopNoPlay(y) {
        const topRows = CONFIG.gameplay.topNoPlayRows || 0;
        return y >= 0 && y < topRows;
      }

      function placeFood() {
        const topRows = CONFIG.gameplay.topNoPlayRows || 0;
        while (true) {
          const x = Math.floor(Math.random() * state.cols);
          const y = Math.floor(Math.random() * state.rows);
          if (y < topRows) continue;
          if (!state.snake.some((s) => s.x === x && s.y === y)) {
            state.food = { x, y };
            break;
          }
        }
      }

      function drawGrid() {
        if (!CONFIG.ui.showGrid) return;
        ctx.strokeStyle = CONFIG.colors.grid;
        ctx.lineWidth = 1;
        for (let x = 0; x <= state.cols; x++) {
          ctx.beginPath();
          ctx.moveTo(x * state.gridSize + 0.5, 0);
          ctx.lineTo(x * state.gridSize + 0.5, canvas.height);
          ctx.stroke();
        }
        for (let y = 0; y <= state.rows; y++) {
          ctx.beginPath();
          ctx.moveTo(0, y * state.gridSize + 0.5);
          ctx.lineTo(canvas.width, y * state.gridSize + 0.5);
          ctx.stroke();
        }
      }

      function drawTopNoPlayZone() {
        const topRows = CONFIG.gameplay.topNoPlayRows || 0;
        if (!topRows) return;
        const h = topRows * state.gridSize;
        ctx.save();
        ctx.globalAlpha = 0.35;
        ctx.fillStyle = CONFIG.colors.noPlay || "#06103a";
        ctx.fillRect(0, 0, canvas.width, h);
        ctx.globalAlpha = 1;
        ctx.strokeStyle = hexToRgba(CONFIG.colors.ui || "#ffffff", 0.25);
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, h + 0.5);
        ctx.lineTo(canvas.width, h + 0.5);
        ctx.stroke();
        ctx.restore();
      }

      function drawRoundedCell(x, y, color, radiusFrac = 0.25) {
        const gs = state.gridSize;
        const px = x * gs, py = y * gs;
        const r = gs * radiusFrac;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(px + r, py);
        ctx.arcTo(px + gs, py, px + gs, py + gs, r);
        ctx.arcTo(px + gs, py + gs, px, py + gs, r);
        ctx.arcTo(px, py + gs, px, py, r);
        ctx.arcTo(px, py, px + gs, py, r);
        ctx.closePath();
        ctx.fill();
      }

      function addParticles(x, y, color) {
        if (!CONFIG.gameplay.particles) return;
        for (let i = 0; i < 8; i++) {
          state.particles.push({
            x: x * state.gridSize + state.gridSize / 2,
            y: y * state.gridSize + state.gridSize / 2,
            vx: (Math.random() - 0.5) * 2.2,
            vy: (Math.random() - 0.5) * 2.2,
            life: 18 + Math.random() * 10,
            color,
          });
        }
      }
      function updateParticles() {
        for (const p of state.particles) {
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.02;
          p.life -= 1;
        }
        state.particles = state.particles.filter((p) => p.life > 0);
      }
      function drawParticles() {
        for (const p of state.particles) {
          const alpha = Math.max(0, Math.min(1, p.life / 20));
          ctx.fillStyle = hexToRgba(CONFIG.colors.particle, alpha);
          ctx.fillRect(p.x - 1.5, p.y - 1.5, 3, 3);
        }
      }

      function hexToRgba(hex, a = 1) {
        const h = hex.replace("#", "");
        const bigint = parseInt(h, 16);
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = bigint & 255;
        return `rgba(${r},${g},${b},${a})`;
      }

      const AudioMgr = {
        ctx: null,
        gain: null,
        init() {
          if (this.ctx) return;
          try {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.gain = this.ctx.createGain();
            this.gain.connect(this.ctx.destination);
            this.setMute(isMuted);
          } catch (e) {}
        },
        setMute(m) {
          isMuted = !!m;
          if (!this.gain) return;
          this.gain.gain.value = isMuted ? 0 : 0.9;
        },
        tone(freq = 440, dur = 0.08, type = "sine") {
          if (!this.ctx) return;
          const o = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          o.type = type;
          o.frequency.value = freq;
          o.connect(g);
          g.connect(this.gain);
          const t = this.ctx.currentTime;
          g.gain.setValueAtTime(0.0001, t);
          g.gain.exponentialRampToValueAtTime(0.4, t + 0.01);
          g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
          o.start();
          o.stop(t + dur + 0.02);
        },
        play(name) {
          if (isMuted) return;
          if (loadedSounds[name]) {
            loadedSounds[name].currentTime = 0;
            loadedSounds[name].play();
          } else {
            if (name === "eat") this.tone(680, 0.07, "triangle");
            if (name === "hit") this.tone(140, 0.18, "square");
          }
        },
      };

      let touchStart = null;
      function onTouchStart(e) {
        AudioMgr.init();
        const t = e.touches[0];
        touchStart = { x: t.clientX, y: t.clientY, time: performance.now() };
      }
      function onTouchMove(e) {
        e.preventDefault();
      }
      function onTouchEnd(e) {
        if (!touchStart) return;
        const t = e.changedTouches[0];
        const dx = t.clientX - touchStart.x;
        const dy = t.clientY - touchStart.y;
        const ax = Math.abs(dx), ay = Math.abs(dy);
        if (ax < 12 && ay < 12) {
          touchStart = null;
          return;
        }
        if (ax > ay) {
          if (dx > 0) setDir(1, 0);
          else setDir(-1, 0);
        } else {
          if (dy > 0) setDir(0, 1);
          else setDir(0, -1);
        }
        tryHaptic();
        touchStart = null;
        hintEl.style.display = "none";
      }
      function onKey(e) {
        if (e.key === "ArrowUp") setDir(0, -1);
        if (e.key === "ArrowDown") setDir(0, 1);
        if (e.key === "ArrowLeft") setDir(-1, 0);
        if (e.key === "ArrowRight") setDir(1, 0);
        if (e.key === " ") startGame();
        if (e.key === "Enter") startGame();
      }
      function setDir(x, y) {
        if (state.dir.x === -x && state.dir.y === -y) return;
        state.nextDir = { x, y };
      }

      function step() {
        state.dir = state.nextDir;
        let head = { x: state.snake[0].x + state.dir.x, y: state.snake[0].y + state.dir.y };

        const wrap = CONFIG.gameplay.wrapWalls;
        const topRows = CONFIG.gameplay.topNoPlayRows || 0;
        const noPlayMode = CONFIG.gameplay.noPlayActsAs || "wrap";

        if (wrap) {
          head.x = (head.x + state.cols) % state.cols;
        } else {
          if (head.x < 0 || head.x >= state.cols) return die();
        }

        if (!wrap) {
          if (head.y < 0 || head.y >= state.rows) return die();
        } else {
          if (head.y < 0) {
            head.y = state.rows - 1;
          } else if (head.y >= state.rows) {
            head.y = 0;
          }
        }

        if (cellInTopNoPlay(head.y)) {
          if (noPlayMode === "wall") {
            return die();
          } else {
            head.y = topRows;
            if (state.dir.y < 0 || head.y < topRows) {
              head.y = state.rows - 1;
            }
            if (cellInTopNoPlay(head.y)) head.y = topRows;
          }
        }

        if (state.snake.some((s) => s.x === head.x && s.y === head.y)) return die();

        state.snake.unshift(head);
        if (head.x === state.food.x && head.y === state.food.y) {
          state.score += CONFIG.gameplay.foodScore;
          hudScore.textContent = state.score;
          addParticles(head.x, head.y, CONFIG.colors.particle);
          AudioMgr.play("eat");
          tryHaptic();
          const ms = state.stepMs;
          const delta =
            1000 / (CONFIG.player.baseSpeed + CONFIG.player.speedIncreasePerFood) - 1000 / CONFIG.player.baseSpeed;
          state.stepMs = Math.max(ms - (delta || 0.5), CONFIG.player.minStepMs);
          placeFood();
        } else {
          state.snake.pop();
        }
      }

      function die() {
        AudioMgr.play("hit");
        tryHaptic();
        state.gameState = "gameover";
        finalScoreEl.textContent = state.score;
        if (state.score > state.best) {
          state.best = state.score;
          localStorage.setItem("eatgrow_best", String(state.best));
        }
        hudBest.textContent = state.best;
  showGameOver();
        tryGameOver(state.score);
  // Game over sonrası: on-chain / leaderboard disabled in game-only mode
      }

      function drawFoodIcon(kind, cx, cy, size) {
        ctx.save();
        if (kind === "heart") {
          const s = size;
          const r = s * 0.25;
          ctx.translate(cx, cy);
          ctx.fillStyle = CONFIG.colors.foodPrimary;
          ctx.beginPath();
          ctx.moveTo(0, s * 0.28);
          ctx.bezierCurveTo(-s * 0.5, -s * 0.1, -s * 0.52, -s * 0.55, -s * 0.22, -s * 0.62);
          ctx.bezierCurveTo(-s * 0.02, -s * 0.66, s * 0.12, -s * 0.54, 0, -s * 0.4);
          ctx.bezierCurveTo(s * 0.12, -s * 0.54, s * 0.02, -s * 0.66, s * 0.22, -s * 0.62);
          ctx.bezierCurveTo(s * 0.52, -s * 0.55, s * 0.5, -s * 0.1, 0, s * 0.28);
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = hexToRgba("#ffffff", 0.25);
          ctx.beginPath();
          ctx.ellipse(-s * 0.12, -s * 0.42, r, r * 0.7, -0.6, 0, Math.PI * 2);
          ctx.fill();
        } else if (kind === "burger") {
          const s = size;
          ctx.translate(cx, cy);
          ctx.fillStyle = CONFIG.colors.foodSecondary;
          ctx.beginPath();
          ctx.roundRect(-s * 0.5, -s * 0.46, s, s * 0.38, s * 0.2);
          ctx.fill();
          ctx.fillStyle = "#38d17a";
          ctx.fillRect(-s * 0.45, -s * 0.12, s * 0.9, s * 0.08);
          ctx.fillStyle = "#6b3e2e";
          ctx.fillRect(-s * 0.46, -s * 0.04, s * 0.92, s * 0.1);
          ctx.fillStyle = "#ffcf33";
          ctx.fillRect(-s * 0.3, 0.06 * s, s * 0.6, s * 0.08);
          ctx.fillStyle = CONFIG.colors.foodSecondary;
          ctx.beginPath();
          ctx.roundRect(-s * 0.5, s * 0.12, s, s * 0.26, s * 0.12);
          ctx.fill();
        }
        ctx.restore();
      }

      function draw() {
        ctx.fillStyle = CONFIG.colors.background;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawTopNoPlayZone();
        drawGrid();
        const pulse = (performance.now() / 600) % 1;
        const scale = 0.8 + Math.sin(pulse * 2 * Math.PI) * 0.05;
        const s = state.gridSize * scale;
        const fx = state.food.x * state.gridSize + state.gridSize / 2;
        const fy = state.food.y * state.gridSize + state.gridSize / 2;
        const kind = CONFIG.gameplay.foodShape === "auto" ? CONFIG.gameplay.foodKind : CONFIG.gameplay.foodShape;
        drawFoodIcon((kind === "circle" || kind === "square") ? "heart" : kind, fx, fy, s * 0.8);
        if (kind === "square") {
          ctx.fillStyle = CONFIG.colors.foodPrimary;
          ctx.beginPath();
          ctx.roundRect(fx - s * 0.4, fy - s * 0.4, s * 0.8, s * 0.8, 6);
          ctx.fill();
        }
        if (kind === "circle") {
          ctx.fillStyle = CONFIG.colors.foodPrimary;
          ctx.beginPath();
          ctx.arc(fx, fy, s * 0.36, 0, Math.PI * 2);
          ctx.fill();
        }
        for (let i = state.snake.length - 1; i >= 0; i--) {
          const seg = state.snake[i];
          const color = i === 0 ? CONFIG.colors.snakeHead : CONFIG.colors.snakeBody;
          const roundFrac = i === 0 ? CONFIG.player.roundedHead : CONFIG.player.roundedBody;
          drawRoundedCell(seg.x, seg.y, color, roundFrac);
        }
        drawParticles();
      }

      function loop(ts) {
        if (!state.lastTime) state.lastTime = ts;
        const dt = ts - state.lastTime;
        state.lastTime = ts;
        if (state.gameState === "playing") {
          state.tAccum += dt;
          while (state.tAccum >= state.stepMs) {
            step();
            state.tAccum -= state.stepMs;
          }
          updateParticles();
          draw();
        } else if (state.gameState === "start") {
          draw();
        }
        requestAnimationFrame(loop);
      }

      function showStart() {
        overlay.style.display = "grid";
        gameOverEl.style.display = "none";
        gameOverEl.classList.remove('show');
      }
      function showGameOver() {
        overlay.style.display = "none";
        gameOverEl.style.display = "grid";
        // animate and focus Play Again for accessibility
        gameOverEl.classList.add('show');
        setTimeout(() => {
          try { if (againBtn && typeof againBtn.focus === 'function') againBtn.focus(); } catch (e) {}
        }, 60);
      }

      function startGame() {
        if (state.gameState === "playing") return;
        AudioMgr.init();
        state.gameState = "playing";
        overlay.style.display = "none";
        gameOverEl.style.display = "none";
        if (CONFIG.ui.showSwipeHint) hintEl.style.display = "block";
      }

      window.onConfigUpdate = (cfg) => {
        canvas.style.backgroundColor = cfg.colors.background;
        gameTitleEl.textContent = cfg.ui.interfaceTitle;
        applyDifficulty();
      };

      async function main() {
        await initConfig();
        initAssets();
        canvas.style.backgroundColor = CONFIG.colors.background;
        gameTitleEl.textContent = CONFIG.ui.interfaceTitle;
        hudBest.textContent = state.best;
        applyDifficulty();
        resetGame();
        showStart();
        tryReady();
        attachSDKListeners();
        const sdkPoll = setInterval(() => {
          if (!sdkListenersAttached) attachSDKListeners();
          else clearInterval(sdkPoll);
        }, 300);
        setTimeout(() => clearInterval(sdkPoll), 5000);

        window.addEventListener("keydown", onKey);
        window.addEventListener("resize", resizeCanvas);
        canvas.addEventListener("touchstart", onTouchStart, { passive: false });
        canvas.addEventListener("touchmove", onTouchMove, { passive: false });
        canvas.addEventListener("touchend", onTouchEnd);
        startBtn.addEventListener("click", () => {
          resetGame();
          startGame();
        });
        againBtn.addEventListener("click", () => {
          resetGame();
          startGame();
        });
        // Sharing and profile/leaderboard navigation removed in game-only mode
        requestAnimationFrame(loop);
      }

      async function fetchJSON(url, opts) {
        try {
          const res = await fetch(url, opts);
          if (!res.ok) return null;
          return await res.json();
        } catch { return null; }
      }

      function trophyForRank(rank) {
        if (rank === 1) return '🥇';
        if (rank === 2) return '🥈';
        if (rank === 3) return '🥉';
        return '#' + rank;
      }

      // Leaderboard and on-chain submission disabled in game-only mode.

      // Listen for on-chain status messages from parent
      window.addEventListener('message', (event) => {
        if (event.origin !== window.location.origin) return;
        const data = event.data;
        const statusEl = document.getElementById('onchainStatus');
        if (!statusEl) return;
        if (!data || typeof data !== 'object') return;
        if (data.type === 'ONCHAIN_STATUS') {
          statusEl.textContent = data.message || '';
        } else if (data.type === 'ONCHAIN_HASH') {
          const h = data.hash || '';
          statusEl.textContent = `Transaction sent! Hash: ${String(h).slice(0,10)}…`;
        } else if (data.type === 'ONCHAIN_CONFIRMED') {
          statusEl.textContent = '✅ Score submitted on-chain!';
        } else if (data.type === 'ONCHAIN_ERROR') {
          statusEl.textContent = 'Error: ' + (data.message || 'unknown');
        }
      });

      async function submitScoreOnChain(score) {
        const statusEl = document.getElementById('onchainStatus');
        if (!statusEl) return;
        statusEl.textContent = 'Checking contract…';
        // eslint-disable-next-line no-undef
        const eth = window.ethereum;
        if (!eth) {
          // Fallback: ask parent (React app) to submit via wagmi/OnchainKit
          statusEl.textContent = 'Using app wallet…';
          window.parent?.postMessage({ type: 'SUBMIT_ONCHAIN_SCORE', score }, window.location.origin);
          return;
        }

        try {
          const accounts = await eth.request({ method: 'eth_requestAccounts' });
          if (!accounts || accounts.length === 0) {
            statusEl.textContent = 'No account connected.';
            return;
          }
          const userAddress = accounts[0];

          // Contract details (değişken olarak da tanımlayabiliriz ya da URL'den çekebiliriz)
          const contractAddress = '0x0000000000000000000000000000000000000000'; // Replaced by parent bridge if not available
          if (contractAddress === '0x0000000000000000000000000000000000000000') {
            statusEl.textContent = 'Contract not deployed yet.';
            return;
          }

          // ABI subset for submitScore
          const abi = [{"inputs":[{"name":"_score","type":"uint256"}],"name":"submitScore","outputs":[],"stateMutability":"nonpayable","type":"function"}];
          const iface = new ethers.utils.Interface(abi);
          const data = iface.encodeFunctionData('submitScore', [BigInt(score)]);

          statusEl.textContent = 'Requesting wallet signature…';
          const txHash = await eth.request({
            method: 'eth_sendTransaction',
            params: [{
              from: userAddress,
              to: contractAddress,
              data
            }]
          });

          statusEl.textContent = `Transaction sent! Hash: ${txHash.slice(0,10)}…`;
          // Poll for receipt
          let receipt = null;
          for (let i = 0; i < 60; i++) {
            receipt = await eth.request({ method: 'eth_getTransactionReceipt', params: [txHash] });
            if (receipt) break;
            await new Promise(r => setTimeout(r, 1000));
          }
          if (receipt && receipt.status === '0x1') {
            statusEl.textContent = '✅ Score submitted on-chain!';
          } else {
            statusEl.textContent = receipt ? 'Transaction failed.' : 'Transaction pending…';
          }
        } catch (e) {
          statusEl.textContent = 'Error: ' + (e.message || 'unknown');
        }
      }

      async function generateScorePoster(score, username, walletAddress, rank) {
        // Canvas ile poster oluştur
        const posterCanvas = document.createElement('canvas');
        posterCanvas.width = 800;
        posterCanvas.height = 1000;
        const ctx = posterCanvas.getContext('2d');

        // Gradient background
        const grad = ctx.createLinearGradient(0, 0, 0, 1000);
        grad.addColorStop(0, '#0b1228');
        grad.addColorStop(0.5, '#1a2847');
        grad.addColorStop(1, '#0b1228');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 800, 1000);

        // Başlık
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 48px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('🐍 Snakebase', 400, 100);

        // Skor
        ctx.font = 'bold 96px system-ui';
        ctx.fillStyle = '#3ee686';
        ctx.fillText(String(score), 400, 350);
        
        ctx.font = '32px system-ui';
        ctx.fillStyle = '#aaa';
        ctx.fillText('SCORE', 400, 400);

        // Kullanıcı bilgisi
        ctx.font = 'bold 36px system-ui';
        ctx.fillStyle = '#fff';
        const displayName = username || (walletAddress ? walletAddress.slice(0,6) + '…' + walletAddress.slice(-4) : 'Player');
        ctx.fillText(displayName, 400, 500);

        if (rank && rank > 0) {
          ctx.font = '28px system-ui';
          ctx.fillStyle = '#ffd97d';
          let rankIcon = '🏆';
          if (rank === 1) rankIcon = '🥇';
          if (rank === 2) rankIcon = '🥈';
          if (rank === 3) rankIcon = '🥉';
          ctx.fillText(`${rankIcon} Rank #${rank}`, 400, 560);
        }

        // Footer
        ctx.font = '24px system-ui';
        ctx.fillStyle = '#888';
        ctx.fillText('Play on Base • snakebase.vercel.app', 400, 920);

        // Canvas'ı blob'a dönüştür
        return new Promise((resolve) => {
          posterCanvas.toBlob((blob) => {
            resolve(blob);
          }, 'image/png');
        });
      }

      async function shareToFarcaster(score) {
        const sess = await fetchJSON('/api/auth/session');
        const username = sess?.user?.username || 'Player';
        const walletAddress = sess?.user?.walletAddress || null;
        
        // Top leaderboard'dan rank bul
        const topData = await fetchJSON('/api/leaderboard/top?limit=100');
        let rank = 0;
        if (topData && topData.top && walletAddress) {
          const idx = topData.top.findIndex(r => r.walletAddress.toLowerCase() === walletAddress.toLowerCase());
          if (idx >= 0) rank = idx + 1;
        }

        // Share frame URL'si oluştur
        const shareUrl = new URL('/share', window.location.origin);
        shareUrl.searchParams.set('score', String(score));
        shareUrl.searchParams.set('username', username);
        if (rank > 0) shareUrl.searchParams.set('rank', String(rank));
        if (walletAddress) shareUrl.searchParams.set('wallet', walletAddress);

        const text = `🐍 Just scored ${score} on Snakebase! 🎮\n\n${rank > 0 ? `Rank #${rank} 🏆` : ''}\n\n`;
        
        // Farcaster Warpcast share intent with embed
        const url = `https://warpcast.com/~/compose?text=${encodeURIComponent(text)}&embeds[]=${encodeURIComponent(shareUrl.toString())}`;
        window.open(url, '_blank');
      }

      async function shareToTwitter(score) {
        const sess = await fetchJSON('/api/auth/session');
        const username = sess?.user?.username || 'Player';
        const walletAddress = sess?.user?.walletAddress || null;
        
        const topData = await fetchJSON('/api/leaderboard/top?limit=100');
        let rank = 0;
        if (topData && topData.top && walletAddress) {
          const idx = topData.top.findIndex(r => r.walletAddress.toLowerCase() === walletAddress.toLowerCase());
          if (idx >= 0) rank = idx + 1;
        }

        // Share frame URL'si oluştur
        const shareUrl = new URL('/share', window.location.origin);
        shareUrl.searchParams.set('score', String(score));
        shareUrl.searchParams.set('username', username);
        if (rank > 0) shareUrl.searchParams.set('rank', String(rank));
        if (walletAddress) shareUrl.searchParams.set('wallet', walletAddress);

        const text = `🐍 Just scored ${score} on Snakebase! 🎮\n\n${rank > 0 ? `Rank #${rank} 🏆` : ''}\n\nPlay on @base:\n${shareUrl.toString()}`;
        
        const url = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}`;
        window.open(url, '_blank');
      }

      async function shareToBase(score) {
        const sess = await fetchJSON('/api/auth/session');
        const username = sess?.user?.username || 'Player';
        const walletAddress = sess?.user?.walletAddress || null;
        
        const topData = await fetchJSON('/api/leaderboard/top?limit=100');
        let rank = 0;
        if (topData && topData.top && walletAddress) {
          const idx = topData.top.findIndex(r => r.walletAddress.toLowerCase() === walletAddress.toLowerCase());
          if (idx >= 0) rank = idx + 1;
        }

        // Share frame URL'si oluştur
        const shareUrl = new URL('/share', window.location.origin);
        shareUrl.searchParams.set('score', String(score));
        shareUrl.searchParams.set('username', username);
        if (rank > 0) shareUrl.searchParams.set('rank', String(rank));
        if (walletAddress) shareUrl.searchParams.set('wallet', walletAddress);

        // Base ecosystem için Farcaster tercih edilir
        const text = `🐍 Just scored ${score} on Snakebase (Base)! 🎮\n\n${rank > 0 ? `Rank #${rank} 🏆` : ''}\n\n`;
        
        const url = `https://warpcast.com/~/compose?text=${encodeURIComponent(text)}&embeds[]=${encodeURIComponent(shareUrl.toString())}`;
        window.open(url, '_blank');
      }

      if (!CanvasRenderingContext2D.prototype.roundRect) {
        CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
          if (w < 2 * r) r = w / 2;
          if (h < 2 * r) r = h / 2;
          this.beginPath();
          this.moveTo(x + r, y);
          this.arcTo(x + w, y, x + w, y + h, r);
          this.arcTo(x + w, y + h, x, y + h, r);
          this.arcTo(x, y + h, x, y, r);
          this.arcTo(x, y, x + w, y, r);
          this.closePath();
          return this;
        };
      }

      main();
    </script>

    <!-- Game UI Elements -->
    <div id="wrap">
      <canvas id="canvas" width="600" height="900"></canvas>
    </div>

    <div id="hud">
      <div id="scoreLabel">Score</div>
      <div id="score">0</div>
      <div id="bestLabel">Best</div>
      <div id="best">0</div>
    </div>

    <div id="overlay" class="overlay">
      <div class="panel">
        <div id="gameTitle">Eat & Grow</div>
        <div id="subtitle">Collect the food, don't hit walls or your tail!</div>

        <div id="howTitle">How to Play</div>
        <ul id="howList">
          <li>Controls: Swipe (mobile) • Arrow Keys (desktop)</li>
          <li>Top dark area is a no-play zone — food never spawns there. Depending on settings it acts as wrap or a wall.</li>
        </ul>

        <div id="itemsTitle">Items</div>
        <ul id="itemsList">
          <li>Heart: +Score, slightly increases your speed</li>
          <li>Burger: +Score, slightly increases your speed</li>
        </ul>

        <button id="startBtn" class="btn">Start Game</button>
      </div>
    </div>

    <div id="gameOver" class="overlay">
      <div class="panel">
        <div id="gameOverTitle">Game Over</div>
        <div id="finalScore">Score: 0</div>
        <button id="againBtn" class="btn">Play Again</button>
      </div>
    </div>

    <div id="hint" class="gesture-hint">
      <div id="controlsHint">Swipe to move</div>
      <div class="config-hint">Tap to continue</div>
    </div>

    <!-- Hidden game assets -->
    <script type="application/json" id="game-assets">
      {
        "sounds": {
          "eat": "/sounds/eat.mp3",
          "hit": "/sounds/hit.mp3"
        }
      }
    </script>
  </body>
</html>
