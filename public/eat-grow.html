<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Eat & Grow - Snake Game</title>
    <style>
        :root {
            --ui-safe: env(safe-area-inset-bottom, 0px);
        }

        html, body {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            background: #0b0f1a;
            overflow: hidden;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
            color: #fff;
        }

        @supports (height: 100svh) {
            html, body {
                height: 100svh;
            }
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #canvas {
            border: 2px solid #3ee686;
            border-radius: 8px;
            background: #0b0f1a;
            max-width: 90vw;
            max-height: 80vh;
            image-rendering: pixelated;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 20px;
            font-weight: bold;
            z-index: 10;
        }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 20px;
            border: 2px solid #3ee686;
            z-index: 20;
            max-width: 90vw;
        }

        #start-screen h1, #game-over-screen h1 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            color: #3ee686;
        }

        #start-screen p, #game-over-screen p {
            font-size: 1.2rem;
            margin-bottom: 30px;
            color: #ccc;
        }

        .button {
            background: linear-gradient(180deg, #94f7b7 0%, #3ee686 100%);
            color: #0b0f1a;
            border: none;
            padding: 15px 30px;
            border-radius: 12px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.1s;
        }

        .button:hover {
            transform: scale(1.05);
        }

        .button:active {
            transform: scale(0.95);
        }

        #gesture-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.9rem;
            color: #ccc;
            z-index: 10;
        }

        @media (max-width: 768px) {
            #canvas {
                max-width: 95vw;
                max-height: 70vh;
            }

            #start-screen, #game-over-screen {
                padding: 30px;
                max-width: 95vw;
            }

            #start-screen h1, #game-over-screen h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="hud">
            <span>Score: <span id="score">0</span></span>
            <span>Best: <span id="best">0</span></span>
        </div>

        <canvas id="canvas"></canvas>

        <div id="start-screen">
            <h1>üêç Snakebase</h1>
            <p>Swipe to move and eat the food to grow!</p>
            <button id="start-btn" class="button">Start Game</button>
        </div>

        <div id="game-over-screen" style="display: none;">
            <h1>Game Over</h1>
            <p id="final-score">Score: 0</p>
            <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                <button id="play-again-btn" class="button">Play Again</button>
                <button id="share-btn" class="button">Share Score</button>
            </div>
        </div>

        <div id="gesture-hint">Swipe to move</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const startBtn = document.getElementById('start-btn');
        const playAgainBtn = document.getElementById('play-again-btn');
        const shareBtn = document.getElementById('share-btn');
        const scoreEl = document.getElementById('score');
        const bestEl = document.getElementById('best');
        const finalScoreEl = document.getElementById('final-score');
        const gestureHint = document.getElementById('gesture-hint');

        // Game state
        let gameState = 'menu'; // menu, playing, gameover
        let snake = [];
        let food = {};
        let direction = { x: 0, y: 0 };
        let nextDirection = { x: 0, y: 0 };
        let score = 0;
        let bestScore = parseInt(localStorage.getItem('snakebase_best') || '0');
        let gameLoop;
        let lastTime = 0;
        const gameSpeed = 150; // milliseconds

        // Game constants
        const gridSize = 20;
        const tileCount = 20;

        function initGame() {
            canvas.width = tileCount * gridSize;
            canvas.height = tileCount * gridSize;

            // Initialize snake
            snake = [
                { x: 10, y: 10 }
            ];

            // Initialize direction
            direction = { x: 0, y: 0 };
            nextDirection = { x: 0, y: 0 };

            // Initialize score
            score = 0;
            scoreEl.textContent = score;
            bestEl.textContent = bestScore;

            // Place initial food
            placeFood();

            // Hide screens
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            gestureHint.style.display = 'block';
        }

        function startGame() {
            if (gameState === 'menu') {
                initGame();
                gameState = 'playing';
                gameLoop = requestAnimationFrame(gameStep);
            }
        }

        function placeFood() {
            let newFood;
            do {
                newFood = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount)
                };
            } while (snake.some(segment => segment.x === newFood.x && segment.y === newFood.y));

            food = newFood;
        }

        function gameStep(currentTime) {
            if (currentTime - lastTime < gameSpeed) {
                gameLoop = requestAnimationFrame(gameStep);
                return;
            }
            lastTime = currentTime;

            update();
            draw();

            if (gameState === 'playing') {
                gameLoop = requestAnimationFrame(gameStep);
            }
        }

        function update() {
            // Update direction
            direction = { ...nextDirection };

            // Move snake
            const head = { ...snake[0] };
            head.x += direction.x;
            head.y += direction.y;

            // Check wall collision
            if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
                gameOver();
                return;
            }

            // Check self collision
            if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                gameOver();
                return;
            }

            snake.unshift(head);

            // Check food collision
            if (head.x === food.x && head.y === food.y) {
                score += 10;
                scoreEl.textContent = score;
                placeFood();
            } else {
                snake.pop();
            }
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = '#0b0f1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = '#1a1a2e';
            ctx.lineWidth = 1;
            for (let i = 0; i <= tileCount; i++) {
                ctx.beginPath();
                ctx.moveTo(i * gridSize, 0);
                ctx.lineTo(i * gridSize, canvas.height);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, i * gridSize);
                ctx.lineTo(canvas.width, i * gridSize);
                ctx.stroke();
            }

            // Draw snake
            ctx.fillStyle = '#3ee686';
            for (let i = 0; i < snake.length; i++) {
                const segment = snake[i];
                const x = segment.x * gridSize;
                const y = segment.y * gridSize;

                if (i === 0) {
                    // Head - slightly different color
                    ctx.fillStyle = '#94f7b7';
                    ctx.fillRect(x + 2, y + 2, gridSize - 4, gridSize - 4);
                    ctx.fillStyle = '#3ee686';
                } else {
                    ctx.fillRect(x + 1, y + 1, gridSize - 2, gridSize - 2);
                }
            }

            // Draw food
            ctx.fillStyle = '#ff6b6b';
            ctx.fillRect(food.x * gridSize + 3, food.y * gridSize + 3, gridSize - 6, gridSize - 6);
        }

        function gameOver() {
            gameState = 'gameover';

            // Update best score
            if (score > bestScore) {
                bestScore = score;
                localStorage.setItem('snakebase_best', bestScore.toString());
                bestEl.textContent = bestScore;
            }

            // Show game over screen
            finalScoreEl.textContent = `Score: ${score}`;
            gameOverScreen.style.display = 'block';
            gestureHint.style.display = 'none';

            // Cancel game loop
            if (gameLoop) {
                cancelAnimationFrame(gameLoop);
            }
        }

        function resetGame() {
            gameState = 'menu';
            startScreen.style.display = 'block';
            gameOverScreen.style.display = 'none';
        }

        // Event listeners
        startBtn.addEventListener('click', startGame);
        playAgainBtn.addEventListener('click', () => {
            resetGame();
            startGame();
        });

        shareBtn.addEventListener('click', () => {
            const text = `I scored ${score} points in Snakebase! Can you beat my score? üêçüéÆ`;
            const url = window.location.origin;

            if (navigator.share) {
                navigator.share({
                    title: 'Snakebase Score',
                    text: text,
                    url: url
                });
            } else {
                // Fallback: copy to clipboard
                navigator.clipboard.writeText(`${text} ${url}`).then(() => {
                    alert('Score copied to clipboard!');
                });
            }
        });

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (gameState !== 'playing') return;

            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    if (direction.y === 0) nextDirection = { x: 0, y: -1 };
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    if (direction.y === 0) nextDirection = { x: 0, y: 1 };
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    if (direction.x === 0) nextDirection = { x: -1, y: 0 };
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    if (direction.x === 0) nextDirection = { x: 1, y: 0 };
                    break;
            }
        });

        // Touch controls
        let touchStartX = 0;
        let touchStartY = 0;

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
        });

        canvas.addEventListener('touchend', (e) => {
            if (gameState !== 'playing') return;

            e.preventDefault();
            const touch = e.changedTouches[0];
            const deltaX = touch.clientX - touchStartX;
            const deltaY = touch.clientY - touchStartY;

            const minSwipeDistance = 30;

            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                // Horizontal swipe
                if (Math.abs(deltaX) > minSwipeDistance) {
                    if (deltaX > 0 && direction.x === 0) {
                        nextDirection = { x: 1, y: 0 };
                    } else if (deltaX < 0 && direction.x === 0) {
                        nextDirection = { x: -1, y: 0 };
                    }
                }
            } else {
                // Vertical swipe
                if (Math.abs(deltaY) > minSwipeDistance) {
                    if (deltaY > 0 && direction.y === 0) {
                        nextDirection = { x: 0, y: 1 };
                    } else if (deltaY < 0 && direction.y === 0) {
                        nextDirection = { x: 0, y: -1 };
                    }
                }
            }
        });

        // Listen for parent messages
        window.addEventListener('message', (event) => {
            if (event.origin !== window.location.origin) return;

            const data = event.data;
            if (!data || typeof data !== 'object') return;

            if (data.type === 'AUTO_START') {
                console.log('Received AUTO_START from parent');
                startGame();
                window.parent?.postMessage({ type: 'AUTO_START_ACK' }, window.location.origin);
            }

            if (data.type === 'REGISTER_PLAYER') {
                console.log('Player registered:', data.user);
            }
        });

        // Initialize
        resetGame();
    </script>
</body>
</html>
